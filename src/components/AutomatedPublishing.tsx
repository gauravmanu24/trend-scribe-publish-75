
import React, { useState } from "react";
import { useInterval } from "@/hooks/useInterval";
import { Card } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import { useToast } from "@/hooks/use-toast";
import { PlusCircle, Play, Loader2 } from "lucide-react";
import { v4 as uuidv4 } from "uuid";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { useAppStore } from "@/lib/store";

// Import our new components
import AutomationSourceForm from "./automation/AutomationSourceForm";
import AutomationLogsList from "./automation/AutomationLogsList";
import AutomationSourcesList from "./automation/AutomationSourcesList";
import AutomationProcessingCard from "./automation/AutomationProcessingCard";
import DeleteSourceDialog from "./automation/DeleteSourceDialog";

const AutomatedPublishing = () => {
  const { toast } = useToast();
  const feeds = useAppStore((state) => state.feeds);
  const sources = useAppStore((state) => state.automationSources);
  const setSources = useAppStore((state) => state.setAutomationSources);
  const logs = useAppStore((state) => state.automationLogs);
  const addLog = useAppStore((state) => state.addAutomationLog);
  const clearLogs = useAppStore((state) => state.clearAutomationLogs);
  const addArticle = useAppStore((state) => state.addArticle);
  const isPolling = useAppStore((state) => state.isPolling);
  const setPolling = useAppStore((state) => state.setPolling);
  const pollingInterval = useAppStore((state) => state.pollingInterval);
  const setPollingInterval = useAppStore((state) => state.setPollingInterval);
  const lastManualRun = useAppStore((state) => state.lastManualRun);
  const setLastManualRun = useAppStore((state) => state.setLastManualRun);
  const wordPressConfig = useAppStore((state) => state.wordPressConfig);
  const openRouterConfig = useAppStore((state) => state.openRouterConfig);
  
  const [isEditingSource, setIsEditingSource] = useState(false);
  const [editSourceId, setEditSourceId] = useState<string | null>(null);
  const [isSourceSheetOpen, setIsSourceSheetOpen] = useState(false);
  const [sourceToDelete, setSourceToDelete] = useState<string | null>(null);
  const [isDeleteDialogOpen, setIsDeleteDialogOpen] = useState(false);
  
  const [isRunningAction, setIsRunningAction] = useState(false);
  const [autoPublish, setAutoPublish] = useState(false);
  const [activeTab, setActiveTab] = useState("sources");
  const [processingTitles, setProcessingTitles] = useState<string[]>([]);
  const [currentProcessingIndex, setCurrentProcessingIndex] = useState<number | null>(null);
  const [processingSourceId, setProcessingSourceId] = useState<string | null>(null);
  const [totalTitlesToProcess, setTotalTitlesToProcess] = useState<number>(0);
  const [titlesProcessed, setTitlesProcessed] = useState<number>(0);

  const processNextTitle = async (sourceId: string, titles: string[], index: number) => {
    if (index >= titles.length) {
      setIsRunningAction(false);
      setCurrentProcessingIndex(null);
      setProcessingSourceId(null);
      setProcessingTitles([]);
      setTitlesProcessed(0);
      setTotalTitlesToProcess(0);
      
      const updatedSources = sources.map((s) => 
        s.id === sourceId 
          ? { ...s, lastProcessed: new Date().toISOString() }
          : s
      );
      
      setSources(updatedSources);
      setLastManualRun(new Date().toISOString());
      
      toast({
        title: "Processing completed",
        description: `All ${titles.length} articles have been processed`,
      });
      
      return;
    }
    
    const title = titles[index];
    setCurrentProcessingIndex(index);
    setTitlesProcessed(index + 1);
    
    try {
      const logId = uuidv4();
      const source = sources.find(s => s.id === sourceId);
      const sourceName = source?.name || "Unknown source";
      
      addLog({
        id: logId,
        sourceId: sourceId,
        sourceName: sourceName,
        title: title,
        status: "processing",
        timestamp: new Date().toISOString(),
        message: `Processing article: ${title}`,
      });
      
      const delay = ms => new Promise(resolve => setTimeout(resolve, ms));
      await delay(2000);
      
      const content = `<h1>${title}</h1><p>This is a sample article content for "${title}". In a real application, this would be generated by an AI service based on the title.</p><h2>Section 1</h2><p>Content for section 1...</p><h2>Section 2</h2><p>Content for section 2...</p>`;
      
      const articleId = uuidv4();
      addArticle({
        title: title,
        content: content,
        status: "generated",
        createdAt: new Date().toISOString(),
        publishedAt: null,
        sourceTitle: title,
        sourceLink: null,
        category: "general",
        wordpressPostId: null,
        wordpressPostUrl: null,
        customPrompt: "",
      });
      
      addLog({
        id: uuidv4(),
        sourceId: sourceId,
        sourceName: sourceName,
        title: title,
        status: "success",
        timestamp: new Date().toISOString(),
        message: `Successfully generated article: ${title}`,
        articleId: articleId,
      });
      
      if (autoPublish && wordPressConfig.isConnected) {
        await delay(1000);
        
        addLog({
          id: uuidv4(),
          sourceId: sourceId,
          sourceName: sourceName,
          title: title,
          status: "success",
          timestamp: new Date().toISOString(),
          message: `Published to WordPress: ${title}`,
          articleId: articleId,
        });
      }
      
      setTimeout(() => {
        processNextTitle(sourceId, titles, index + 1);
      }, 500);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : "Unknown error occurred";
      
      addLog({
        id: uuidv4(),
        sourceId: sourceId,
        sourceName: sources.find(s => s.id === sourceId)?.name || "Unknown source",
        title: title,
        status: "failed",
        timestamp: new Date().toISOString(),
        message: `Failed to process article: ${errorMessage}`,
      });
      
      toast({
        title: "Processing failed",
        description: `Failed to process title: ${title}. Error: ${errorMessage}`,
        variant: "destructive",
      });
      
      setTimeout(() => {
        processNextTitle(sourceId, titles, index + 1);
      }, 500);
    }
  };

  const handleRunSource = async (sourceId: string) => {
    const source = sources.find((s) => s.id === sourceId);
    if (!source) return;
    
    if (isRunningAction) {
      toast({
        title: "Action in progress",
        description: "Please wait for the current operation to complete",
        variant: "destructive",
      });
      return;
    }
    
    if (!openRouterConfig.isConnected && !openRouterConfig.apiKey) {
      toast({
        title: "AI service not configured",
        description: "Please configure an AI service in settings before running",
        variant: "destructive",
      });
      return;
    }
    
    if (autoPublish && (!wordPressConfig.isConnected || !wordPressConfig.url)) {
      toast({
        title: "WordPress not connected",
        description: "Please connect WordPress in settings or disable auto-publish",
        variant: "destructive",
      });
      return;
    }
    
    const titles = source.titles || [];
    if (titles.length === 0) {
      toast({
        title: "No titles to process",
        description: "This source has no titles to process",
        variant: "destructive",
      });
      return;
    }
    
    setIsRunningAction(true);
    setProcessingSourceId(sourceId);
    setProcessingTitles(titles);
    setTotalTitlesToProcess(titles.length);
    setTitlesProcessed(0);
    
    toast({
      title: "Processing started",
      description: `Starting to process ${titles.length} articles from ${source.name}`,
    });
    
    processNextTitle(sourceId, titles, 0);
  };

  const handleRunAllSources = async () => {
    if (isRunningAction) {
      toast({
        title: "Action in progress",
        description: "Please wait for the current operation to complete",
        variant: "destructive",
      });
      return;
    }
    
    const activeSources = sources.filter(s => s.isActive);
    if (activeSources.length === 0) {
      toast({
        title: "No active sources",
        description: "There are no active sources to run",
        variant: "destructive",
      });
      return;
    }
    
    toast({
      title: "Run all sources",
      description: `This feature is not yet implemented`,
    });
  };

  const toggleSourceStatus = (id: string) => {
    const updatedSources = sources.map((s) => 
      s.id === id ? { ...s, isActive: !s.isActive } : s
    );
    
    setSources(updatedSources);
    
    const source = updatedSources.find((s) => s.id === id);
    toast({
      title: source?.isActive ? "Source activated" : "Source deactivated",
      description: `${source?.name} has been ${source?.isActive ? "activated" : "deactivated"}`,
    });
  };

  useInterval(
    () => {
      if (sources.length === 0) return;
      
      console.log("Polling: checking for new content...");
    },
    isPolling ? pollingInterval * 60 * 1000 : null
  );

  const handleEditSource = (id: string) => {
    const sourceToEdit = sources.find((s) => s.id === id);
    if (sourceToEdit) {
      setEditSourceId(id);
      setIsEditingSource(true);
      setIsSourceSheetOpen(true);
    }
  };

  const handleDeleteSource = (id: string) => {
    setSourceToDelete(id);
    setIsDeleteDialogOpen(true);
  };

  const confirmDeleteSource = () => {
    if (sourceToDelete) {
      const sourceName = sources.find((s) => s.id === sourceToDelete)?.name || "Source";
      const updatedSources = sources.filter((s) => s.id !== sourceToDelete);
      setSources(updatedSources);
      
      toast({
        title: "Source deleted",
        description: `${sourceName} has been removed`,
      });
    }
    
    setSourceToDelete(null);
    setIsDeleteDialogOpen(false);
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <div>
          <h1 className="text-2xl font-bold text-gray-800">Automated Publishing</h1>
          <p className="text-muted-foreground">
            Setup sources and automatically generate and publish content
          </p>
        </div>
        
        <div className="flex items-center space-x-2">
          <div className="flex items-center space-x-2 mr-4">
            <Label htmlFor="auto-publish" className="text-sm">Auto-publish</Label>
            <Switch 
              id="auto-publish" 
              checked={autoPublish} 
              onCheckedChange={setAutoPublish}
              disabled={!wordPressConfig.isConnected}
            />
          </div>
          
          <Button 
            variant="outline" 
            size="sm" 
            onClick={() => setIsSourceSheetOpen(true)}
          >
            <PlusCircle className="mr-2 h-4 w-4" />
            Add Source
          </Button>
          
          <Button
            variant="outline"
            size="sm"
            onClick={handleRunAllSources}
            disabled={isRunningAction || sources.length === 0}
          >
            {isRunningAction ? (
              <>
                <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                Running...
              </>
            ) : (
              <>
                <Play className="mr-2 h-4 w-4" />
                Run All Sources
              </>
            )}
          </Button>
        </div>
      </div>

      <AutomationProcessingCard 
        isRunningAction={isRunningAction}
        processingSourceId={processingSourceId}
        sources={sources}
        titlesProcessed={titlesProcessed}
        totalTitlesToProcess={totalTitlesToProcess}
        currentProcessingIndex={currentProcessingIndex}
        processingTitles={processingTitles}
      />
      
      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <TabsList>
          <TabsTrigger value="sources">Sources</TabsTrigger>
          <TabsTrigger value="logs">Activity Logs</TabsTrigger>
        </TabsList>
        
        <TabsContent value="sources" className="space-y-4">
          <AutomationSourcesList 
            sources={sources}
            onAddSource={() => setIsSourceSheetOpen(true)}
            onEditSource={handleEditSource}
            onDeleteSource={handleDeleteSource}
            onToggleSourceStatus={toggleSourceStatus}
            onRunSource={handleRunSource}
            isRunningAction={isRunningAction}
            processingSourceId={processingSourceId}
            titlesProcessed={titlesProcessed}
            totalTitlesToProcess={totalTitlesToProcess}
          />
        </TabsContent>
        
        <TabsContent value="logs">
          <AutomationLogsList 
            logs={logs}
            clearLogs={clearLogs}
          />
        </TabsContent>
      </Tabs>
      
      <AutomationSourceForm 
        isOpen={isSourceSheetOpen}
        onOpenChange={setIsSourceSheetOpen}
        sources={sources}
        setSources={setSources}
        isEditingSource={isEditingSource}
        setIsEditingSource={setIsEditingSource}
        editSourceId={editSourceId}
        setEditSourceId={setEditSourceId}
      />
      
      <DeleteSourceDialog 
        isOpen={isDeleteDialogOpen}
        onOpenChange={setIsDeleteDialogOpen}
        onConfirm={confirmDeleteSource}
      />
    </div>
  );
};

export default AutomatedPublishing;
